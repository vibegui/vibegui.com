---
phase: 03-supabase-schema-import
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
requirements:
  - SUPA-01
  - SUPA-02
  - SUPA-03
  - SUPA-04
  - SUPA-05
  - SUPA-06

must_haves:
  truths:
    - "Articles table exists in Supabase with all required columns"
    - "Tags and article_tags junction tables exist with foreign keys"
    - "Slug uniqueness is enforced by database constraint"
    - "GIN index on search_vector enables full-text search"
    - "Search vector trigger updates automatically on article insert/update"
    - "Tag changes propagate to article search_vector via secondary trigger"
    - "RLS blocks anonymous writes but allows public reads of published articles"
    - "Authenticated users can read drafts, anonymous users cannot"
  artifacts:
    - path: "Supabase: articles table"
      provides: "Article storage with slug, title, description, content, status, date, cover_image, search_vector, audit columns"
      contains: "UNIQUE constraint on slug"
    - path: "Supabase: tags table"
      provides: "Normalized tag names"
      contains: "UNIQUE constraint on name"
    - path: "Supabase: article_tags table"
      provides: "Junction table linking articles to tags"
      contains: "Composite primary key (article_id, tag_id)"
    - path: "Supabase: update_article_search_vector function"
      provides: "Trigger function building weighted tsvector from title(A) + description(B) + content(C) + tags(D)"
    - path: "Supabase: update_article_search_on_tag_change function"
      provides: "Trigger function that touches article updated_at when tags change"
  key_links:
    - from: "article_tags.article_id"
      to: "articles.id"
      via: "FOREIGN KEY ON DELETE CASCADE"
    - from: "article_tags.tag_id"
      to: "tags.id"
      via: "FOREIGN KEY ON DELETE CASCADE"
    - from: "articles_search_vector_update trigger"
      to: "update_article_search_vector function"
      via: "BEFORE INSERT OR UPDATE on articles"
    - from: "article_tags_search_update trigger"
      to: "update_article_search_on_tag_change function"
      via: "AFTER INSERT OR DELETE on article_tags"
---

<objective>
Create the complete Supabase schema for articles: tables, indexes, triggers, and RLS policies.

Purpose: Establish the database foundation that articles will be imported into and queried from. This is the prerequisite for the import script and all future article operations.
Output: Three tables (articles, tags, article_tags), search vector triggers, GIN index, and RLS policies — all applied to the vibegui Supabase database.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-supabase-schema-import/03-RESEARCH.md
@lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create articles, tags, and article_tags tables with indexes</name>
  <files>(Supabase database — no local files modified)</files>
  <action>
Apply a single migration via Supabase MCP `apply_migration` tool to create the schema. The Supabase project ID is `juzhkuutiuqkyuwbcivk` (visible in lib/supabase.ts URL).

If the MCP tool returns an authorization error, fall back to using `execute_sql` or ask the user to re-authorize the Supabase MCP token.

The migration SQL must create:

1. **articles table:**
   - `id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY`
   - `slug TEXT NOT NULL UNIQUE`
   - `title TEXT NOT NULL`
   - `description TEXT NOT NULL`
   - `content TEXT NOT NULL`
   - `status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published'))` — per user decision: simple draft/published enum
   - `date DATE NOT NULL` — per user decision: date only, no time component
   - `cover_image TEXT` — nullable, per user decision: URL string column
   - `search_vector TSVECTOR` — populated by trigger, not generated column
   - `created_by TEXT NOT NULL DEFAULT 'unknown'`
   - `updated_by TEXT NOT NULL DEFAULT 'unknown'`
   - `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`
   - `updated_at TIMESTAMPTZ NOT NULL DEFAULT now()`

2. **tags table:**
   - `id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY`
   - `name TEXT NOT NULL UNIQUE`

3. **article_tags junction table:** — per user decision: junction table, not text[] array
   - `article_id BIGINT NOT NULL REFERENCES articles(id) ON DELETE CASCADE`
   - `tag_id BIGINT NOT NULL REFERENCES tags(id) ON DELETE CASCADE`
   - `PRIMARY KEY (article_id, tag_id)` — composite PK, no separate ID

4. **Indexes:**
   - `articles_slug_idx ON articles (slug)` — for slug lookups
   - `articles_status_idx ON articles (status)` — for filtering by status
   - `articles_date_idx ON articles (date DESC)` — for chronological ordering
   - `articles_search_vector_idx ON articles USING GIN (search_vector)` — for full-text search
   - `article_tags_article_id_idx ON article_tags (article_id)` — for join performance
   - `article_tags_tag_id_idx ON article_tags (tag_id)` — for join performance

Use the exact SQL from the research document's "Complete Schema DDL" section.
  </action>
  <verify>
After applying the migration, verify the tables exist using Supabase MCP:
- `list_tables` for project `juzhkuutiuqkyuwbcivk` with schemas `["public"]`
- Confirm articles, tags, and article_tags appear in the table list
  </verify>
  <done>Three tables (articles, tags, article_tags) exist in Supabase with all specified columns, constraints (slug UNIQUE, composite PK), and indexes (GIN on search_vector, btree on slug/status/date).</done>
</task>

<task type="auto">
  <name>Task 2: Create triggers (updated_at, search_vector, tag propagation) and RLS policies</name>
  <files>(Supabase database — no local files modified)</files>
  <action>
Apply a second migration via Supabase MCP `apply_migration` to create triggers and RLS policies.

**Triggers (3 functions, 3 triggers):**

1. **updated_at trigger:**
   ```sql
   CREATE OR REPLACE FUNCTION update_updated_at()
   RETURNS trigger AS $$
   BEGIN
     NEW.updated_at = now();
     RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;

   CREATE TRIGGER articles_updated_at
     BEFORE UPDATE ON articles
     FOR EACH ROW
     EXECUTE FUNCTION update_updated_at();
   ```

2. **Search vector trigger** — per user decision: 'simple' language config, title > description > content weights, trigger-based (not generated column because tags are in junction table):
   ```sql
   CREATE OR REPLACE FUNCTION update_article_search_vector()
   RETURNS trigger AS $$
   DECLARE
     tag_text TEXT;
   BEGIN
     SELECT COALESCE(string_agg(t.name, ' '), '') INTO tag_text
     FROM article_tags at
     JOIN tags t ON t.id = at.tag_id
     WHERE at.article_id = NEW.id;

     NEW.search_vector :=
       setweight(to_tsvector('simple', COALESCE(NEW.title, '')), 'A') ||
       setweight(to_tsvector('simple', COALESCE(NEW.description, '')), 'B') ||
       setweight(to_tsvector('simple', COALESCE(NEW.content, '')), 'C') ||
       setweight(to_tsvector('simple', tag_text), 'D');

     RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;

   CREATE TRIGGER articles_search_vector_update
     BEFORE INSERT OR UPDATE ON articles
     FOR EACH ROW
     EXECUTE FUNCTION update_article_search_vector();
   ```

3. **Tag change propagation trigger** — touches article's updated_at to fire the search vector trigger:
   ```sql
   CREATE OR REPLACE FUNCTION update_article_search_on_tag_change()
   RETURNS trigger AS $$
   DECLARE
     affected_article_id BIGINT;
   BEGIN
     affected_article_id := COALESCE(NEW.article_id, OLD.article_id);
     UPDATE articles SET updated_at = now()
     WHERE id = affected_article_id;
     RETURN NULL;
   END;
   $$ LANGUAGE plpgsql;

   CREATE TRIGGER article_tags_search_update
     AFTER INSERT OR DELETE ON article_tags
     FOR EACH ROW
     EXECUTE FUNCTION update_article_search_on_tag_change();
   ```

**RLS Policies:**

Enable RLS on all three tables, then create policies:

```sql
ALTER TABLE articles ENABLE ROW LEVEL SECURITY;
ALTER TABLE tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE article_tags ENABLE ROW LEVEL SECURITY;
```

Per user decisions:
- Drafts hidden from public (anon only sees published)
- Authenticated can read all articles (including drafts)
- Write access: service role only (bypasses RLS automatically, no explicit write policies needed)
- Tags/article_tags: service role only for writes, but anon/authenticated need SELECT for displaying tags on the blog

Policies:
```sql
-- Articles
CREATE POLICY "Public can read published articles" ON articles FOR SELECT TO anon USING (status = 'published');
CREATE POLICY "Authenticated can read all articles" ON articles FOR SELECT TO authenticated USING (true);

-- Tags (read access for display, writes via service_role bypass)
CREATE POLICY "Public can read tags" ON tags FOR SELECT TO anon USING (true);
CREATE POLICY "Authenticated can read tags" ON tags FOR SELECT TO authenticated USING (true);

-- Article_tags (read access for joins, writes via service_role bypass)
CREATE POLICY "Public can read article_tags" ON article_tags FOR SELECT TO anon USING (true);
CREATE POLICY "Authenticated can read article_tags" ON article_tags FOR SELECT TO authenticated USING (true);
```
  </action>
  <verify>
Verify triggers and RLS using Supabase MCP `execute_sql`:
1. `SELECT tgname FROM pg_trigger WHERE tgrelid = 'articles'::regclass;` — should show articles_updated_at and articles_search_vector_update
2. `SELECT tgname FROM pg_trigger WHERE tgrelid = 'article_tags'::regclass;` — should show article_tags_search_update
3. `SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public' ORDER BY tablename, policyname;` — should show 6 policies across 3 tables

Run security advisors check: `get_advisors` with type "security" to confirm no RLS warnings.
  </verify>
  <done>Three trigger functions and three triggers are active. RLS is enabled on all three tables with 6 policies: anon reads published articles, authenticated reads all articles, anon+authenticated read tags and article_tags. No security advisor warnings for missing RLS.</done>
</task>

</tasks>

<verification>
1. `list_tables` confirms articles, tags, article_tags exist in public schema
2. `execute_sql` with `SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'articles' ORDER BY ordinal_position;` confirms all columns
3. `execute_sql` with `SELECT indexname FROM pg_indexes WHERE tablename IN ('articles', 'article_tags') ORDER BY indexname;` confirms indexes
4. Insert a test article and verify search_vector is populated automatically
5. Delete the test article after verification
6. `get_advisors` security check passes
</verification>

<success_criteria>
- articles, tags, article_tags tables exist with correct columns and constraints
- slug UNIQUE constraint enforced
- GIN index on search_vector exists
- Search vector trigger fires on INSERT/UPDATE with weighted A/B/C/D ranking
- Tag change trigger propagates to article search_vector
- RLS enabled on all tables with correct policy configuration
- Security advisors show no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-supabase-schema-import/03-01-SUMMARY.md`
</output>
