---
phase: 03-supabase-schema-import
plan: 02
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - scripts/import-articles.ts
autonomous: true
requirements:
  - SUPA-07
  - IMPT-01
  - IMPT-02
  - IMPT-03
  - IMPT-04

must_haves:
  truths:
    - "Import script reads all 52 markdown articles using existing readAllArticles()"
    - "Zod schema validates each article before insert attempt"
    - "Invalid articles are skipped with error logged, not aborting the run"
    - "Dry-run mode previews all 52 articles without touching the database"
    - "Live run upserts all 52 articles with tags into Supabase"
    - "Re-running the import is safe (upsert on slug, no duplicates)"
    - "Post-import count query confirms exactly 52 articles in database"
  artifacts:
    - path: "scripts/import-articles.ts"
      provides: "Import script that reads markdown articles and upserts into Supabase"
      contains: "readAllArticles"
      min_lines: 80
  key_links:
    - from: "scripts/import-articles.ts"
      to: "lib/articles.ts"
      via: "import { readAllArticles }"
      pattern: "readAllArticles"
    - from: "scripts/import-articles.ts"
      to: "Supabase articles table"
      via: "supabaseAdmin.from('articles').upsert()"
      pattern: "\\.upsert\\("
    - from: "scripts/import-articles.ts"
      to: "Supabase article_tags table"
      via: "delete + insert pattern for tag management"
      pattern: "article_tags"
---

<objective>
Write and execute the import script that loads all 52 markdown articles into Supabase, with validation, dry-run mode, and tag management.

Purpose: Populate the Supabase articles table from the existing markdown files, establishing the database as the source of truth. The script must be idempotent (safe to re-run via upsert).
Output: `scripts/import-articles.ts` that successfully imports all 52 articles with tags, verified by count query.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-supabase-schema-import/03-RESEARCH.md
@.planning/phases/03-supabase-schema-import/03-01-SUMMARY.md
@lib/articles.ts
@lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create import script with dry-run, validation, upsert, and tag management</name>
  <files>scripts/import-articles.ts</files>
  <action>
Create `scripts/import-articles.ts` that imports all markdown articles into Supabase. The script uses the service role client (not the anon client from lib/supabase.ts).

**Environment setup:**
- Read `VITE_SUPABASE_URL` and `SUPABASE_SERVICE_KEY` from process.env
- Use `dotenv` or read `.env` manually if needed (check how other scripts in `scripts/` handle env vars — likely Bun auto-loads `.env`)
- Create a service role Supabase client with `persistSession: false, autoRefreshToken: false`

**Script structure:**

1. **Parse CLI args:** Check for `--dry-run` flag in `process.argv`

2. **Read articles:** Call `readAllArticles("blog/articles")` from `lib/articles.ts`
   - This already validates via Zod schema at parse time
   - If any article fails to parse, readArticle returns null and it's skipped by readAllArticles

3. **Wrap each article in try/catch** — per user decision: skip and log on failure, continue with rest

4. **For each article:**
   a. **Map frontmatter to DB columns:**
      - `slug` -> slug
      - `title` -> title
      - `description` -> description
      - `content` -> content (the markdown body)
      - `status` -> status (already 'draft' or 'published' from Zod enum)
      - `date` -> date (already YYYY-MM-DD string, PostgreSQL auto-casts to date type)
      - `coverImage` -> cover_image (camelCase to snake_case)
      - `created_by` -> 'import-script' — per user decision: agent name in audit columns
      - `updated_by` -> 'import-script'

   b. **Upsert article** — per user decision: match by slug, update if exists, insert if new
      ```typescript
      const { data, error } = await supabaseAdmin
        .from("articles")
        .upsert({ slug, title, description, content, status, date, cover_image, created_by, updated_by }, { onConflict: "slug" })
        .select("id, slug")
        .single();
      ```
      IMPORTANT: Chain `.select("id, slug").single()` — supabase-js v2 does NOT return rows by default.

   c. **Manage tags** (delete + re-insert pattern from research):
      - Delete existing article_tags for this article_id
      - If article has tags: upsert tag names into tags table (onConflict: 'name'), fetch tag IDs, insert junction rows

   d. **In dry-run mode:** Log what would be upserted (slug, title, tag count) but skip all DB operations

5. **Print summary:** `{success} imported, {skipped} skipped`
   - If errors, print each: `SKIPPED: {slug} - {error message}`

6. **Verify count (live mode only):**
   ```typescript
   const { count } = await supabaseAdmin
     .from("articles")
     .select("*", { count: "exact", head: true });
   console.log(`Verification: ${count} articles in database`);
   ```

**Validation (SUPA-07):** The Zod schema already validates at parse time in `readArticle()`. The import script does NOT need additional Zod validation — it's handled by the parser. If an article has invalid frontmatter, `readArticle()` throws, and `readAllArticles()` skips it (returns null). The import script's try/catch around each article handles any remaining errors.

**Running the script:**
- `bun run scripts/import-articles.ts --dry-run` — preview mode
- `bun run scripts/import-articles.ts` — live import
  </action>
  <verify>
1. Run dry-run first: `bun run scripts/import-articles.ts --dry-run`
   - Should list all 52 articles with "Would upsert:" prefix
   - Should report "52 success, 0 skipped"
   - No database changes

2. Run live import: `bun run scripts/import-articles.ts`
   - Should report "52 imported, 0 skipped"
   - Should print "Verification: 52 articles in database"

3. Run import again to verify idempotency:
   - Should succeed with same results (upsert updates existing rows)

4. Verify via Supabase MCP `execute_sql`:
   - `SELECT COUNT(*) FROM articles;` — should return 52
   - `SELECT COUNT(*) FROM tags;` — should return > 0
   - `SELECT COUNT(*) FROM article_tags;` — should return > 0
   - `SELECT slug, title, status FROM articles ORDER BY date DESC LIMIT 5;` — spot check
   - `SELECT a.slug, t.name FROM articles a JOIN article_tags at ON at.article_id = a.id JOIN tags t ON t.id = at.tag_id ORDER BY a.slug LIMIT 10;` — verify tag associations
   - `SELECT slug, search_vector IS NOT NULL as has_search FROM articles LIMIT 5;` — verify search vectors populated
  </verify>
  <done>
Import script exists at scripts/import-articles.ts. Dry-run shows 52 articles would be imported. Live run inserts all 52 articles with tags. Count query confirms exactly 52 articles. Re-run produces identical results (upsert idempotency). Search vectors are populated on all articles.
  </done>
</task>

</tasks>

<verification>
1. `scripts/import-articles.ts` file exists and runs without errors
2. Dry-run mode lists all 52 articles without database changes
3. Live import inserts 52 articles, verified by count query
4. Tags are correctly associated (junction table populated)
5. Search vectors are populated (trigger fired during insert)
6. Re-running import is safe (upsert, no duplicates)
7. `bun run scripts/import-articles.ts --dry-run` exits cleanly
</verification>

<success_criteria>
- Import script reads all 52 articles from blog/articles/*.md
- Validation happens at parse time via existing Zod schema
- Invalid articles are skipped with logged errors (none expected since Phase 2 validated all 52)
- Dry-run mode previews without writing
- Live run upserts all 52 articles into Supabase
- Tags managed via delete + re-insert on junction table
- Post-import count query confirms exactly 52 articles
- Script is idempotent (safe to re-run)
</success_criteria>

<output>
After completion, create `.planning/phases/03-supabase-schema-import/03-02-SUMMARY.md`
</output>
